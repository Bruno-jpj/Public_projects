import numpy as np
import matplotlib.pyplot as plt

# const cells
ROBOT = 2  # orange
OCCUPIED = -1  # red
FREE = 0  # green
UNKNOWN = 1  # gray

# const robot
ROBOT_X, ROBOT_Y, ROBOT_Z = 5, 5, 5
START_POINT = (0, 0, 0)

# create map3D known cause Obj Robot
def create_map3D(dim_x, dim_y, dim_z, start_pos):
    mappa = {}
    for x in range(dim_x):
        for y in range(dim_y):
            for z in range(dim_z):
                mappa[(x, y, z)] = UNKNOWN
    # metti il robot nella posizione iniziale
    mappa[start_pos] = ROBOT
    return mappa

# create example-test obj
def create_obstacle(mappa):
    # esempio: blocco alcune celle centrali
    for x in range(2, 4):
        for y in range(2, 4):
            for z in range(1, 3):
                mappa[(x, y, z)] = OCCUPIED

# update map and robot position
def update_map(mappa, old_pos, new_pos):
    # libera vecchia cella
    if old_pos in mappa and mappa[old_pos] != OCCUPIED:
        mappa[old_pos] = FREE
    # aggiorna nuova cella
    if new_pos in mappa and mappa[new_pos] != OCCUPIED:
        mappa[new_pos] = ROBOT
        return new_pos
    else:
        print("Collisione o fuori mappa!")
        return old_pos  # ritorna a vecchia posizione se non valido

# draw map
def draw_map(mappa, ax):
    max_x = max(pos[0] for pos in mappa.keys()) + 1
    max_y = max(pos[1] for pos in mappa.keys()) + 1
    max_z = max(pos[2] for pos in mappa.keys()) + 1

    voxels = np.zeros((max_x, max_y, max_z), dtype=bool)
    colors = np.empty(voxels.shape, dtype=object)

    for (x, y, z), status in mappa.items():
        if status != UNKNOWN:  # mostro solo celle viste
            voxels[x, y, z] = True
            if status == OCCUPIED:
                colors[x, y, z] = "red"
            elif status == ROBOT:
                colors[x, y, z] = "orange"
            elif status == FREE:
                colors[x, y, z] = "green"

    ax.clear()
    ax.voxels(voxels, facecolors=colors, edgecolor="k")
    ax.set_xlabel("X")
    ax.set_ylabel("Y")
    ax.set_zlabel("Z")
    ax.set_title("Simulazione robot 3D")
    plt.pause(0.1)

def main():
    global robot_pos, mappa, ax  # rendi globali per callback
    robot_pos = START_POINT
    mappa = create_map3D(ROBOT_X, ROBOT_Y, ROBOT_Z, START_POINT)
    create_obstacle(mappa)

    moves = {
        "w": (0, 1, 0),   # avanti
        "s": (0, -1, 0),  # indietro
        "a": (-1, 0, 0),  # sinistra
        "d": (1, 0, 0),   # destra
        "r": (0, 0, 1),   # su
        "f": (0, 0, -1)   # gi√π
    }

    # setup matplotlib interattivo
    plt.ion()
    fig = plt.figure()
    ax = fig.add_subplot(111, projection="3d")
    draw_map(mappa, ax)

    # callback per pressione tasti
    def on_key(event):
        global robot_pos
        if event.key == "q":
            plt.close(fig)
        elif event.key in moves:
            dx, dy, dz = moves[event.key]
            new_pos = (robot_pos[0] + dx, robot_pos[1] + dy, robot_pos[2] + dz)
            robot_pos = update_map(mappa, robot_pos, new_pos)
            draw_map(mappa, ax)

    fig.canvas.mpl_connect("key_press_event", on_key)
    plt.show()  # rimane aperto e interattivo

    # loop principale per tenere viva la finestra
    while plt.fignum_exists(fig.number):
        plt.pause(0.1)

if __name__ == "__main__":
    main()
///*******************************///
import numpy as np
import matplotlib as mpl
import matplotlib.pyplot as plt

def insert_robot(map3D, start_pos, x, y, z, status):
    for i in range(x):
        for j in range(y):
            for k in range(z):
                pos = (start_pos[0] + i, start_pos[1] + j, start_pos[2] + k)
                map3D[pos] = status
    #
    return map3D
#

def main():

    START_POS = [0, 0, 0]

    # width, height, depth
    ROBOT_X, ROBOT_Y, ROBOT_Z = 5, 5 , 7
   
    # status: 0 unknwn, 1 free, -1 occupied
    map3D = {}

    map3D = insert_robot(map3D, START_POS, ROBOT_X, ROBOT_Y, ROBOT_Z, -1)

    # find max dimensions for the grid
    max_x = max(pos[0] for pos in map3D.keys()) + 1
    max_y = max(pos[1] for pos in map3D.keys()) + 1
    max_z = max(pos[2] for pos in map3D.keys()) + 1
    
    # create a 3D grid of voxels
    voxels = np.zeros((max_x, max_y, max_z), dtype=bool)
    colors = np.empty(voxels.shape, dtype=object)

    # populate the grid
    for (x, y, z), s in map3D.items():
        voxels[x, y, z] = True
        if s == -1:   
            colors[x, y, z] = "red"
        elif s == 0:  
            colors[x, y, z] = "gray"
        elif s == 1:  
            colors[x, y, z] = "green"

    # plot the map
    fig = plt.figure()
    ax = fig.add_subplot(111, projection="3d")
    ax.voxels(voxels, facecolors=colors, edgecolor="k")

    ax.set_xlabel("X")
    ax.set_ylabel("Y")
    ax.set_zlabel("Z")
    ax.set_title("Mappa 3D con Voxel")

    plt.show()
#

if __name__ == "__main__":
    main()
/******************************************************************************/
# crea mappa infinita
def create_map3D(start_pos):
    mappa = {}
    mappa[start_pos] = ROBOT  # solo posizione iniziale del robot
    return mappa

# disegno mappe infinite (mostro solo celle conosciute)
def draw_map(mappa, ax, fig):
    if not mappa:
        return
    # calcolo limiti solo sulle celle conosciute
    xs = [pos[0] for pos in mappa.keys()]
    ys = [pos[1] for pos in mappa.keys()]
    zs = [pos[2] for pos in mappa.keys()]

    max_x, min_x = max(xs)+1, min(xs)
    max_y, min_y = max(ys)+1, min(ys)
    max_z, min_z = max(zs)+1, min(zs)

    shape = (max_x - min_x, max_y - min_y, max_z - min_z)
    voxels = np.zeros(shape, dtype=bool)
    colors = np.empty(shape, dtype=object)

    for (x, y, z), status in mappa.items():
        i, j, k = x - min_x, y - min_y, z - min_z
        voxels[i, j, k] = True
        if status == OCCUPIED:
            colors[i, j, k] = "red"
        elif status == ROBOT:
            colors[i, j, k] = "orange"
        elif status == FREE:
            colors[i, j, k] = "green"

    ax.clear()
    ax.voxels(voxels, facecolors=colors, edgecolor="k")
    ax.set_xlabel("X")
    ax.set_ylabel("Y")
    ax.set_zlabel("Z")
    ax.set_title("Simulazione robot 3D")
    fig.canvas.draw_idle()
    fig.canvas.flush_events()
